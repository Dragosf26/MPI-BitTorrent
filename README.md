FROMEA DRAGOS-FLORIN 332 CC

Pentru implementarea acestei teme am creat urmatoarele structuri:
-SwarmResponse: reprezinta informatiile pe care trackerul i le da clientului atunci cand acesta vrea sa descarce un anumit fisier si contine numarul de hash-uri alaturi de hash-urile in sine, numarul de seed-uri si seed-urile, precum si nuamrul de peer-uri si peer-urile.
-File: aceasta structura contine informatiile despre un fisier, mai exact numele acestuia, numarul de segmente si segmentele.
-ClientData: structura folosita la initializarea datelor din tracker. La inceput, fiecare client trimite aceasta structura tracker-ului. Ea contine identificatorul fiecarui tracker(rank), numarul de fisiere continute si fisierele(care contine informatiile mentionate mai sus).
-ClientState: structura unica fiecarui client, contine structura ClientData descrisa mai sus, un vector care contine numele fisierelor pe care clientul doreste sa le descarce("desired_files"), un vector "owned_hashes" care retine hash-urile pe care le are descarcate deja(am creat alt vector pentru a lucra mai usor cu hash-urile, fiind un vector de string-uri; la acesta are acces doar clientul si thread-urile sale, nu il trimit altor procese prin MPI_send, cum il trimit pe vectorul "segments" la initializarea tracker-ului) si un mutex care foloseste la sincronizarea accesului la datele folosite de ambele thread-uri, mai exact la "owned_hashes"

Functia "read_input_file" are rolul de a citi din fisierul coresponzator fiecarui client si de a retine numarul de fisiere pe care le are descarcate clientul("num_owned_files"), numele fisierelor("name"), numarul de segmente("segment_count"), segmentele fisierelor("segments"), numarul de fisiere dorite("num_desired_files") si numele acestora("desired_files").

Functia "create_swarm_response_type" creeaza tipul MPI pentru SwarmResponse.

Functia "create_client_data_type" creeaza tipul MPI pentru ClientData, insa mai intai creeaza tipul MPI pentru File care foloseste la crearea tipului MPI pentru ClientData.

Functia "tracker" foloseste la menegerierea logicii tracker-ului, avand un vector care retine datele initiale ale clientilor("client_info"), un map care retine corespondenta dintre fisiere si hash-uri("file_hashes"), un map pentru corespondenta fisier-seed("file_seeds"), unul pentru fisier-peer("file_peers") si un set care tine evidenta clientilor care au terminat de descarcat fisierele("finished_clients"). Am folosit set pentru a fi sigur ca nu vor fi doua sau mai multe fisiere dublate in vector, deoarece eu la final verific daca lungimea set-ului este egala cu numarul de clienti, adica daca au terminat executia toti clientii. Initial, tracker-ul va primi datele de la fiecare client in parte si va popula map-urile dintre fisier-hash si fisier-seed, apoi va trimite mesaj tuturor clientilor cu mesajul "READY" astfel incat sa poata continua executia. Va intra intr-un loop pana cand toti clientii vor termina executia. In acest loop va astepta mesaj de la clienti si va verifica tipul mesajului. Daca este cerere de swarm, va identifica fisierul si va crea un SwarmResponse pentru fisierul respectiv pe care il va trimite la client care va fi retinut ca peer. Daca este mesaj care anunta terminarea descarcarii unui fisier de catre un client, acesta va fi retinut ca seed. Daca este un mesaj care anunta ca un client a terminat de descarcat toate fisierele de care avea nevoie, va fi trecut in vectorul de clienti care au terminat si apoi se va verifica daca el a fost ultimul care a terminat, daca este adevarat, va trimite un mesaj clientilor astfel incat sa opreasca si thread-urile de upload, apoi se va opri si tracker-ul. Daca este mesaj de update al swarm-ului, va crea un SwarmResponse updatat si il va trimite la client.

Functia "peer" initializeaza mutex-ul fiecarui client("data_mutex"), citeste din fisierul corespunzator, retine hash-urile initiale("owned_hashes") si trimite mesajul de initializarea catre tracker, apoi asteapta mesajul de la acesta pentru a porni executia thread-urilor.

Functia "upload_thread_func" are rolul de a astepta mesaje cat timp mai exista thread-uri de descarcare care ruleaza si se va verifica tipul mesajului. Daca este mesaj de cerere a unui segment, va extrage hash-ul segmentului si va verifica daca il detine, daca da, va trimite mesajul "OK", daca nu, va trimite mesajul "Negativ". Daca mesajul este "done", inseamna ca thread-ul de upload poate opri executia.

Functia "download_thread_func" parcurge fisierele de care are nevoie si va solicita swarm-ul pentru fisierul respectiv, apoi pentru fiecare segment necesar va trimite mesaj aleatoriu unuia dintre seed-uri sau peer-uri pana cand se gaseste un client care sa detina segmentul respectiv. Cand se gaseste(primeste mesajul "OK"), va descarca segmentul respectiv. La fiecare 10 segmente descarcate va trimite o cerere catre tracker pentru a solicita un swarm updatat. Va trimite mesaj la tracker cand a terminat de descarcat un fisier si va scrie hash-urile in fisierele de iesire. Se va goli vectorul temporar care retine hash-urile descarcate pentru a nu se amesteca hash-urile fisierelor intre ele("downloaded_hashes"). Va trimite mesaj la tracker cand a terminat de descarcat toate fisierele de care avea nevoie.

De mentionat ca am ales sa trimit mesajul de cerere a unui segment folosind tag-ul 1 din thread-ul de descarcare si mesajul de confirmare a existentei segmentului la cererea pentru segment cu tagul 2 din functia de upload astfel incat sa se distinga clar faptul ca mesajul de cerere in thread-ul de upload va fi separat de mesajul confirmarii in thread-ul de descarcare, adica cu tagul 1 se va primi in thread-ul de upload si cu tagul 2 in thread-ul de descarcare.
Am folosit mutexul "data_mutex" pentru a rezolva problema sincronizarii accesului la data "owned_hashes" pentru ca ambele thread-uri foloseau acest vector.